@model GameIndexViewModel

@{
    ViewData["Title"] = "Jeux";
}
<h1>Liste des jeux</h1>

<form method="get" asp-action="Index" class="mb-3">
    <!-- Première ligne : Catégorie - Prix min - Prix max - Recherche -->
    <div class="row g-3">
        <div class="col-md-4">
            <label for="categoryId" class="form-label">Catégorie</label>
            <select id="categoryId" name="categoryId" class="form-select">
                <option value="">Toutes</option>
                @{ var selectedId = Model.SelectedCategory; }
                @foreach (var c in Model.Categories)
                {
                    <option value="@c.Id" selected="@(selectedId.HasValue && selectedId.Value == c.Id ? "selected" : null)">@c.Libelle</option>
                }
            </select>
        </div>

        <div class="col-md-2">
            <label for="minPrice" class="form-label">Prix min</label>
            <input type="number" step="1" min="0" id="minPrice" name="minPrice" class="form-control"
                   value="@(Model.MinPrice?.ToString() ?? string.Empty)" />
        </div>

        <div class="col-md-2">
            <label for="maxPrice" class="form-label">Prix max</label>
            <input type="number" step="1" min="0" max="@(Model.GlobalMaxPrice.HasValue ? Model.GlobalMaxPrice.Value.ToString("0") : string.Empty)" id="maxPrice" name="maxPrice"
                   class="form-control" value="@(Model.MaxPrice.HasValue ? Model.MaxPrice.Value.ToString("0") : string.Empty)" />
        </div>

        <div class="col-md-4">
            <label for="search" class="form-label">Rechercher par nom</label>
            <input type="text" id="search" name="search" class="form-control" value="@(Model.Search ?? string.Empty)"
                   placeholder="Nom du jeu..." />
        </div>
    </div>

    <!-- Deuxième ligne : switch à gauche, bouton à droite -->
    <div class="row align-items-center mt-2">
        @if (Model.IsAuthenticated)
        {
            <div class="col-auto">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="onlyOwned" name="onlyOwned" value="true" @(Model.OnlyOwned ? "checked" : null) />
                    <label class="form-check-label" for="onlyOwned">Jeux possédés</label>
                </div>
            </div>
        }
        <div class="col text-end">
            <button type="submit" class="btn btn-primary">Filtrer</button>
        </div>
    </div>
</form>

<!-- Alerte si pas connecté -->
@if (Model.OnlyOwned && !Model.IsAuthenticated)
{
    <div class="alert alert-warning">Vous n'êtes pas connecté. Le filtre "Jeux possédés" ne sera pas appliqué et tous les jeux sont affichés.</div>
}

<div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 g-3">
    @foreach (var g in Model.Games)
    {
        <div class="col">
            <div class="card h-100 game-card @(g.Purchased ? "purchased" : "")" data-game-id="@g.Id" data-purchased="@(g.Purchased ? "true" : "false")">
                <div class="card-body d-flex flex-column">
                    <div class="d-flex justify-content-between align-items-start">
                        <h5 class="card-title mb-0">@g.Name</h5>
                        <div class="text-end text-primary fw-bold">@g.Price.ToString("C")</div>
                    </div>
                    <div class="mt-2 small text-muted">@string.Join(", ", g.Categories.Select(c => c.Libelle))</div>

                    <div class="mt-auto d-flex justify-content-end">
                        @if (Model.IsAuthenticated)
                        {
                            <button class="btn btn-success btn-sm purchase-btn d-none">Acheter</button>
                            <button class="btn @(g.HasPayload ? "btn-primary" : "btn-secondary") btn-sm install-btn d-none" data-has-payload="@(g.HasPayload ? "true" : "false")" @(g.HasPayload ? "" : "disabled=\"disabled\"") aria-disabled="@(g.HasPayload ? "false" : "true")" title="@(g.HasPayload ? "" : "Pas de binaire disponible")">Installer</button>
                        }
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@section Styles {
    <link rel="stylesheet" href="~/css/game-cards.css" />
}

@section Scripts {
    <script>
        // Initialize buttons visibility based on server-side purchased flag (data-purchased attribute)
        document.querySelectorAll('.game-card').forEach(function(card){
            const purchasedAttr = card.getAttribute('data-purchased');
            const purchasedFlag = purchasedAttr === 'true';
            const purchaseBtn = card.querySelector('.purchase-btn');
            const installBtn = card.querySelector('.install-btn');

            if (purchasedFlag) {
                card.classList.add('purchased');
                if (purchaseBtn) purchaseBtn.style.display = 'none';
                if (installBtn) installBtn.style.display = 'none'; // hidden until hover
            } else {
                card.classList.remove('purchased');
                if (purchaseBtn) purchaseBtn.style.display = 'none';
                if (installBtn) installBtn.style.display = 'none';
            }

            // Wire click handlers
            if (purchaseBtn) {
                purchaseBtn.addEventListener('click', async function(e){
                    e.preventDefault();
                    const gid = card.dataset.gameId;
                    try {
                        const resp = await fetch(`/api/1.0.0/game/purchase/${gid}`, { method: 'POST', headers: { 'Accept': 'application/json' }, credentials: 'same-origin' });

                        if (resp.status === 200) {
                            // Achat réussi -> mettre à jour l'UI : marquer comme purchased
                            card.classList.add('purchased');
                            if (purchaseBtn) purchaseBtn.style.display = 'none';
                            if (installBtn) installBtn.style.display = 'inline-block';
                            alert('Achat effectué.');
                            return;
                        }

                        if (resp.status === 401) {
                            // non authentifié -> rediriger vers login
                            window.location.href = '/Identity/Account/Login?returnUrl=' + encodeURIComponent(window.location.href);
                            return;
                        }

                        if (resp.status === 409) {
                            const text = await resp.text();
                            let parsed;
                            try { parsed = JSON.parse(text); } catch (ex) { parsed = null; }
                            alert((parsed && parsed.message) ? parsed.message : (text || 'Vous possédez déjà ce jeu.'));
                            return;
                        }

                        // Autres erreurs : lire le corps (texte puis JSON) et afficher
                        const text = await resp.text();
                        let parsed;
                        try { parsed = JSON.parse(text); } catch (ex) { parsed = null; }
                        const message = (parsed && parsed.message) ? parsed.message : (text || "Erreur lors de l'achat.");
                        console.error('Purchase error', { status: resp.status, body: text });
                        alert('Erreur lors de l\'achat (HTTP ' + resp.status + '). Détails: ' + (message.length > 500 ? message.substr(0, 500) + '...' : message));

                    } catch (err) {
                        alert('Erreur réseau lors de l\'achat: ' + err.message);
                    }
                });
            }

            if (installBtn) {
                installBtn.addEventListener('click', async function(e){
                    e.preventDefault();
                    const gid = card.dataset.gameId;
                    const hasPayloadAttr = installBtn.getAttribute('data-has-payload') || card.getAttribute('data-has-payload');
                    const hasPayloadFlag = hasPayloadAttr === 'true';
                    if (!hasPayloadFlag) {
                        // Bouton disabled côté HTML ; si le handler est appelé, ne rien faire
                        return;
                    }

                    try {
                        const resp = await fetch(`/api/1.0.0/game/payload/${gid}`, { method: 'GET', credentials: 'same-origin' });

                        if (resp.status === 200) {
                            const blob = await resp.blob();

                            // Essayer d'extraire le filename depuis l'en-tête Content-Disposition
                            let fileName = '';
                            const cd = resp.headers.get('Content-Disposition') || '';
                            try {
                                // RFC 5987: filename*=UTF-8''...
                                const m = /filename\*=UTF-8''([^;\n]+)/i.exec(cd);
                                if (m && m[1]) {
                                    fileName = decodeURIComponent(m[1]);
                                } else {
                                  const m2 = /filename="?([^";]+)"?/i.exec(cd);
                                  if (m2 && m2[1]) fileName = m2[1];
                                }
                            } catch (ex) { /* ignore */ }

                            if (!fileName) {
                                // fallback: use game title text or generic name
                                const titleEl = card.querySelector('.card-title');
                                const titleText = titleEl ? titleEl.textContent.trim() : '';
                                fileName = (titleText ? titleText.replace(/[^a-z0-9_.-]/gi, '_') : `game_${gid}`) + '.bin';
                            }

                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = fileName;
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                            setTimeout(() => URL.revokeObjectURL(url), 1000);
                            return;
                        }

                        if (resp.status === 401) {
                            window.location.href = '/Identity/Account/Login?returnUrl=' + encodeURIComponent(window.location.href);
                            return;
                        }

                        if (resp.status === 403) {
                            alert('Accès refusé : vous ne possédez pas ce jeu.');
                            return;
                        }

                        if (resp.status === 404) {
                            const text = await resp.text();
                            alert((text && text.length) ? text : 'Binaire introuvable.');
                            return;
                        }

                        const text = await resp.text();
                        alert((text && text.length) ? text : ('Erreur lors du téléchargement (HTTP ' + resp.status + ')'));

                    } catch (err) {
                        alert('Erreur réseau lors du téléchargement : ' + err.message);
                    }

                });
            }
        });
    </script>
}
